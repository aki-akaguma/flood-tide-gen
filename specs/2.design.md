# Design Document: flood-tide-gen

## 1. Introduction

This document outlines the design of the `flood-tide-gen` library. The system is designed to read a human-readable, text-based definition of a command-line interface (CLI) and generate the necessary Rust source code for argument parsing, intended for use with the `flood-tide` crate.

## 2. System Architecture

The library follows a modular, process-oriented architecture. The core logic is encapsulated within the `gen` module, which is exposed through a public API in `lib.rs`. The process flows from input file parsing to code generation, with an intermediate step for type customization.

### 2.1. Core Modules

- **`lib.rs`**: Serves as the public facade of the library. It exposes the primary function `do_gen_src` and the necessary data structures like `OptStr`, `MetaType`, `FixupType`, and `Pasc`. It orchestrates the parsing, type fixup, and code generation processes.

- **`gen` (module)**: Contains all the core logic.
    - **`gen/mod.rs`**: This file is the heart of the parsing and file management logic.
        - `parse_input_file0`: Reads the `.txt` definition file line by line, using regular expressions to capture the different parts of an option (short name, long name, meta, comment). It populates a `Vec<OptStr>` with the raw parsed data.
        - `update_file0`: Handles writing the generated source code to disk. It performs a check to prevent writing if the file content is unchanged.
        - It defines the core data structures: `OptStr` for representing a parsed option and `MetaType` for its associated type.

    - **`gen/gen_buffer.rs`**: Implements a `GenBuffer` struct, which is a wrapper around `String`. It provides helper methods (`push_str_ary`, `add_assign`) for efficiently building the large strings of generated code, minimizing re-allocations.

    - **`gen/gen_src_help.rs`**: Responsible for generating the first output file (`cmd.help.rs.txt`).
        - `gen_src_help0`: The main function that orchestrates the generation of different code sections.
        - It generates several key components:
            1.  `OPTIONS_TEXT`: A `const` string containing the original help text.
            2.  `CmdOp`: An enum that provides a unique identifier for each command option.
            3.  `OPT_ARY`: A `const` array of `flood_tide::Opt` structs, which is the primary data structure used by `flood-tide` for parsing.
            4.  `CmdOptConf`: A struct that will hold the parsed values from the command line at runtime.
            5.  `value_to_*`: A series of helper functions to convert the string values from `flood-tide` into the specific data types required by `CmdOptConf`.

    - **`gen/gen_src_match.rs`**: Responsible for generating the second output file (`cmd.match.rs.txt`).
        - `gen_src_match0`: Generates a single, large `match` statement. This statement switches on the `CmdOp` enum and contains the logic to assign the parsed value to the correct field in the `CmdOptConf` struct.

## 3. Data Model

- **`OptStr`**: The central data structure representing a single command option as parsed from the input file. It holds the raw string components (short, long, meta, comment) and derived fields like `enum_s` (the name for the `CmdOp` variant) and `field_s` (the name for the `CmdOptConf` field). It also stores the type information (`meta_type`, `is_vec`, `is_opt`).

- **`MetaType`**: An enum that represents the data type of an option's argument. It covers all standard Rust numeric types, `String`, `bool`, and an `Other(String)` variant for custom types.

- **`FixupType`**: A struct provided by the user via a closure. It allows the user to override the default type information (`is_vec`, `is_opt`, `meta_type`) for a specific `OptStr` after the initial parsing is complete.

- **`Pasc` (Parent and Subcommand)**: An enum (`Void`, `Parent`, `Subcmd`, `PareSubc`) that acts as a flag to control the code generation logic, specifically for adding `subcmd` fields to the `CmdOptConf` struct or generating code for a subcommand context.

## 4. Core Processes

1.  **Parsing**: The `do_gen_src` function calls `parse_input_file0`. A `BufReader` reads the input file line-by-line. A series of `regex` patterns are tested against each line to extract option details. Each successful capture results in a new `OptStr` instance being created and added to a vector.

2.  **Type Fixup**: After parsing, `do_gen_src` iterates through the `Vec<OptStr>`. For each `OptStr`, it calls the user-provided closure `f`. If this closure returns `Some(FixupType)`, the `OptStr` instance is updated with the new type information from the `FixupType`.

3.  **Code Generation**: `do_gen_src` then calls `gen_src_help0` and `gen_src_match0`, passing the (now finalized) `Vec<OptStr>`. These functions use the `GenBuffer` to build the source code strings by iterating over the `Vec<OptStr>` and generating the appropriate Rust syntax for each data structure and match arm.

4.  **File Writing**: The generated strings are passed to `update_file0`. This function first reads the target file (if it exists) and compares its content to the newly generated string. The file is only overwritten if the contents differ.

## 5. Error Handling

Error handling is managed through the `anyhow` crate. Functions that can fail (primarily file I/O and parsing) return a `anyhow::Result<()>`. The `.with_context()` method is used to provide clear, user-friendly error messages that indicate which file operation failed.
