// WARN: This file is auto generated by flood-tide-gen
const OPTIONS_TEXT: &str = r"  -a, --alpha <value>      Alpha value
      --beta               Beta flag
  -g                       Gamma flag
  -i, --input-file <file>  File path
";

#[repr(u8)]
#[derive(Debug, PartialEq, Eq)]
enum CmdOp {
    Alpha,
    Beta,
    LcG,
    InputFile,
}

impl std::convert::From<u8> for CmdOp {
    fn from(value: u8) -> Self {
        unsafe { std::mem::transmute(value) }
    }
}
impl CmdOp {
    pub const fn to(self) -> OptNum {
        self as OptNum
    }
}

#[rustfmt::skip]
const OPT_ARY: [Opt;4] = [
    Opt { sho: b'g', lon: "",              has: Arg::No,  num: CmdOp::LcG.to(), },
    Opt { sho: b'a', lon: "alpha",         has: Arg::Yes, num: CmdOp::Alpha.to(), },
    Opt { sho: 0u8,  lon: "beta",          has: Arg::No,  num: CmdOp::Beta.to(), },
    Opt { sho: b'i', lon: "input-file",    has: Arg::Yes, num: CmdOp::InputFile.to(), },
];

#[rustfmt::skip]
const OPT_ARY_SHO_IDX: [(u8,usize);3] = [
(b'a',1),(b'g',0),(b'i',3),];

#[derive(Debug, Default, PartialEq, Eq)]
pub struct CmdOptConf {
    pub prog_name: String,
    //
    pub opt_alpha: String,
    pub flg_beta: bool,
    pub flg_lc_g: bool,
    pub opt_input_file: PathBuf,
    //
    pub arg_params: Vec<String>,
}

impl flood_tide::HelpVersion for CmdOptConf {
    fn is_help(&self) -> bool {
        false
    }
    fn is_version(&self) -> bool {
        false
    }
}

fn value_to_string(nv: &NameVal<'_>) -> Result<String, OptParseError> {
    match nv.val {
        Some(x) => Ok(x.to_string()),
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}

fn value_to_path(nv: &NameVal<'_>) -> Result<std::path::PathBuf, OptParseError> {
    match nv.val {
        Some(x) => Ok(std::path::PathBuf::from(x)),
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}
