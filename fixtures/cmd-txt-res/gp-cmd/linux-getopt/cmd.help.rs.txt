// WARN: This file is auto generated by flood-tide-gen
const OPTIONS_TEXT: &str = r"Options:
  -a, --alternative             allow long options starting with single -
  -l, --longoptions <longopts>  the long options to be recognized
  -n, --name <progname>         the name under which errors are reported
  -o, --options <optstring>     the short options to be recognized
  -q, --quiet                   disable error reporting by getopt(3)
  -Q, --quiet-output            no normal output
  -s, --shell <shell>           set quoting conventions to those of <shell>
  -T, --test                    test for getopt(1) version
  -u, --unquoted                do not quote the output

  -H, --help        display this help and exit
  -V, --version     display version information and exit
  -X <x-options>    x options. try -X help
";

#[repr(u8)]
#[derive(Debug, PartialEq)]
enum CmdOp {
    Alternative,
    Longoptions,
    Name,
    Options,
    Quiet,
    QuietOutput,
    Shell,
    Test,
    Unquoted,
    Help,
    Version,
    UcX,
}

impl std::convert::From<u8> for CmdOp {
    fn from(value: u8) -> Self {
        unsafe { std::mem::transmute(value) }
    }
}
impl CmdOp {
    pub const fn to(self) -> OptNum {
        self as OptNum
    }
}

#[rustfmt::skip]
const OPT_ARY: [Opt;12] = [
    Opt { sho: b'X', lon: "",              has: Arg::Yes, num: CmdOp::UcX.to(), },
    Opt { sho: b'a', lon: "alternative",   has: Arg::No,  num: CmdOp::Alternative.to(), },
    Opt { sho: b'H', lon: "help",          has: Arg::No,  num: CmdOp::Help.to(), },
    Opt { sho: b'l', lon: "longoptions",   has: Arg::Yes, num: CmdOp::Longoptions.to(), },
    Opt { sho: b'n', lon: "name",          has: Arg::Yes, num: CmdOp::Name.to(), },
    Opt { sho: b'o', lon: "options",       has: Arg::Yes, num: CmdOp::Options.to(), },
    Opt { sho: b'q', lon: "quiet",         has: Arg::No,  num: CmdOp::Quiet.to(), },
    Opt { sho: b'Q', lon: "quiet-output",  has: Arg::No,  num: CmdOp::QuietOutput.to(), },
    Opt { sho: b's', lon: "shell",         has: Arg::Yes, num: CmdOp::Shell.to(), },
    Opt { sho: b'T', lon: "test",          has: Arg::No,  num: CmdOp::Test.to(), },
    Opt { sho: b'u', lon: "unquoted",      has: Arg::No,  num: CmdOp::Unquoted.to(), },
    Opt { sho: b'V', lon: "version",       has: Arg::No,  num: CmdOp::Version.to(), },
];

#[rustfmt::skip]
const OPT_ARY_SHO_IDX: [(u8,usize);12] = [
(b'H',2),(b'Q',7),(b'T',9),(b'V',11),(b'X',0),(b'a',1),(b'l',3),(b'n',4),(b'o',5),(b'q',6),(b's',8),(b'u',10),];

#[derive(Debug, Default, PartialEq)]
pub struct CmdOptConf {
    pub prog_name: String,
    //
    pub flg_alternative: bool,
    pub opt_longoptions: Option<String>,
    pub opt_name: String,
    pub opt_options: Option<String>,
    pub flg_quiet: bool,
    pub flg_quiet_output: bool,
    pub opt_shell: Option<String>,
    pub flg_test: bool,
    pub flg_unquoted: bool,
    pub flg_help: bool,
    pub flg_version: bool,
    pub opt_uc_x: Vec<OptXParam>,
    //
    pub arg_params: Vec<String>,
}

impl flood_tide::HelpVersion for CmdOptConf {
    fn is_help(&self) -> bool {
        self.flg_help
    }
    fn is_version(&self) -> bool {
        self.flg_version
    }
}

fn value_to_string(nv: &NameVal<'_>) -> Result<String, OptParseError> {
    match nv.val {
        Some(x) => Ok(x.to_string()),
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon)),
    }
}

fn value_to_opt_x_param(nv: &NameVal<'_>) -> Result<OptXParam, OptParseError> {
    match nv.val {
        Some(s) => match FromStr::from_str(s) {
            Ok(x) => Ok(x),
            Err(err) => Err(OptParseError::invalid_option_argument(
                &nv.opt.lon,
                &err.to_string(),
            )),
        },
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon)),
    }
}
