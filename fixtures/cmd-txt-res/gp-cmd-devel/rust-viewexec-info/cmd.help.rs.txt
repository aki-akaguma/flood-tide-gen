// WARN: This file is auto generated by flood-tide-gen
const OPTIONS_TEXT: &str = r"Options:
  -h, --file-header         display the file header
  -l, --program-headers     display the program headers
  -S, --section-headers     display the section headers
  -s, --tbl <tbl>           display the symbol table
      --syms                display the symbol table, '.symtab' section
      --dyn-syms            display the dynamic symbol table, '.dynsym' section
  -n, --notes               display core notes
  -r, --relocs              display relocations
  -d, --dynamic             display dynamic section
  -v, --version-info        display version section
  -D, --demangle            demangle function name

  -H, --help        display this help and exit
  -V, --version     display version information and exit
";

#[repr(u8)]
#[derive(Debug, PartialEq)]
enum CmdOp {
    FileHeader,
    ProgramHeaders,
    SectionHeaders,
    Tbl,
    Syms,
    DynSyms,
    Notes,
    Relocs,
    Dynamic,
    VersionInfo,
    Demangle,
    Help,
    Version,
}

impl std::convert::From<u8> for CmdOp {
    fn from(value: u8) -> Self {
        unsafe { std::mem::transmute(value) }
    }
}
impl CmdOp {
    pub const fn to(self) -> OptNum {
        self as OptNum
    }
}

#[rustfmt::skip]
const OPT_ARY: [Opt;13] = [
    Opt { sho: b'D', lon: "demangle",      has: Arg::No,  num: CmdOp::Demangle.to(), },
    Opt { sho: 0u8,  lon: "dyn-syms",      has: Arg::No,  num: CmdOp::DynSyms.to(), },
    Opt { sho: b'd', lon: "dynamic",       has: Arg::No,  num: CmdOp::Dynamic.to(), },
    Opt { sho: b'h', lon: "file-header",   has: Arg::No,  num: CmdOp::FileHeader.to(), },
    Opt { sho: b'H', lon: "help",          has: Arg::No,  num: CmdOp::Help.to(), },
    Opt { sho: b'n', lon: "notes",         has: Arg::No,  num: CmdOp::Notes.to(), },
    Opt { sho: b'l', lon: "program-headers",has: Arg::No,  num: CmdOp::ProgramHeaders.to(), },
    Opt { sho: b'r', lon: "relocs",        has: Arg::No,  num: CmdOp::Relocs.to(), },
    Opt { sho: b'S', lon: "section-headers",has: Arg::No,  num: CmdOp::SectionHeaders.to(), },
    Opt { sho: 0u8,  lon: "syms",          has: Arg::No,  num: CmdOp::Syms.to(), },
    Opt { sho: b's', lon: "tbl",           has: Arg::Yes, num: CmdOp::Tbl.to(), },
    Opt { sho: b'V', lon: "version",       has: Arg::No,  num: CmdOp::Version.to(), },
    Opt { sho: b'v', lon: "version-info",  has: Arg::No,  num: CmdOp::VersionInfo.to(), },
];

#[rustfmt::skip]
const OPT_ARY_SHO_IDX: [(u8,usize);11] = [
(b'D',0),(b'H',4),(b'S',8),(b'V',11),(b'd',2),(b'h',3),(b'l',6),(b'n',5),(b'r',7),(b's',10),(b'v',12),];

#[derive(Debug, PartialEq)]
pub struct SubCmdOptConf<'a> {
    pub parent: &'a CmdOptConf,
    pub prog_name: String,
    //
    pub flg_file_header: bool,
    pub flg_program_headers: bool,
    pub flg_section_headers: bool,
    pub opt_tbl: String,
    pub flg_syms: bool,
    pub flg_dyn_syms: bool,
    pub flg_notes: bool,
    pub flg_relocs: bool,
    pub flg_dynamic: bool,
    pub flg_version_info: bool,
    pub flg_demangle: bool,
    pub flg_help: bool,
    pub flg_version: bool,
    //
    pub arg_params: Vec<String>,
}

impl<'a> SubCmdOptConf<'a> {
    pub fn new(a_parent: &'a CmdOptConf, a_prog_name: String) -> SubCmdOptConf<'a> {
        SubCmdOptConf {
            parent: a_parent,
            prog_name: a_prog_name,
            //
            flg_file_header: Default::default(),
            flg_program_headers: Default::default(),
            flg_section_headers: Default::default(),
            opt_tbl: Default::default(),
            flg_syms: Default::default(),
            flg_dyn_syms: Default::default(),
            flg_notes: Default::default(),
            flg_relocs: Default::default(),
            flg_dynamic: Default::default(),
            flg_version_info: Default::default(),
            flg_demangle: Default::default(),
            flg_help: Default::default(),
            flg_version: Default::default(),
            //
            arg_params: Vec::new(),
        }
    }
}

impl<'a> flood_tide::HelpVersion for SubCmdOptConf<'a> {
    fn is_help(&self) -> bool {
        self.flg_help
    }
    fn is_version(&self) -> bool {
        self.flg_version
    }
}

fn value_to_string(nv: &NameVal<'_>) -> Result<String, OptParseError> {
    match nv.val {
        Some(x) => Ok(x.to_string()),
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon)),
    }
}
